#!/usr/bin/env node

/**
 * GRIZZLAND Development Setup Script
 * Following MONOCODE: One-Command Setup principle
 * Observable Implementation with structured logging
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Observable Implementation: Structured logging
const log = (level, message, metadata = {}) => {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    level,
    message,
    component: 'dev-setup',
    ...metadata,
  };
  console.log(JSON.stringify(logEntry, null, 2));
};

// Explicit Error Handling: Fail Fast, Fail Loud
const executeCommand = (command, description) => {
  try {
    log('INFO', `Starting: ${description}`, { command });
    execSync(command, { stdio: 'inherit' });
    log('SUCCESS', `Completed: ${description}`);
  } catch (error) {
    log('ERROR', `Failed: ${description}`, { 
      error: error.message,
      command,
      exitCode: error.status 
    });
    process.exit(1);
  }
};

// Dependency Transparency: Version checking
const checkNodeVersion = () => {
  const nodeVersion = process.version;
  const requiredVersion = '18.0.0';
  
  log('INFO', 'Checking Node.js version', { 
    current: nodeVersion, 
    required: `>=${requiredVersion}` 
  });

  if (parseInt(nodeVersion.slice(1)) < parseInt(requiredVersion)) {
    log('ERROR', 'Node.js version too old', {
      current: nodeVersion,
      required: requiredVersion,
      solution: 'Please upgrade Node.js'
    });
    process.exit(1);
  }

  log('SUCCESS', 'Node.js version check passed');
};

// Progressive Construction: Environment setup
const setupEnvironment = () => {
  const envFile = '.env.local';
  const envTemplate = `# GRIZZLAND Frontend Environment Variables
# Generated by dev-setup script at ${new Date().toISOString()}

# App Configuration
NEXT_PUBLIC_APP_NAME=GRIZZLAND
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Development Configuration
NODE_ENV=development
NEXT_PUBLIC_ENABLE_PERFORMANCE_MONITORING=true
NEXT_PUBLIC_ENABLE_ANALYTICS=false

# Feature Flags
NEXT_PUBLIC_DEBUG_MODE=true
`;

  if (!fs.existsSync(envFile)) {
    fs.writeFileSync(envFile, envTemplate);
    log('SUCCESS', 'Environment file created', { file: envFile });
  } else {
    log('INFO', 'Environment file already exists', { file: envFile });
  }
};

// Main setup sequence
const main = async () => {
  log('INFO', 'Starting GRIZZLAND development setup');

  try {
    // 1. Check prerequisites
    checkNodeVersion();

    // 2. Install dependencies (Version Pinning)
    executeCommand('npm ci', 'Installing pinned dependencies');

    // 3. Setup environment
    setupEnvironment();

    // 4. Run type checking
    executeCommand('npm run type-check', 'Running TypeScript type check');

    // 5. Run linting
    executeCommand('npm run lint', 'Running ESLint');

    // 6. Build project to verify setup
    executeCommand('npm run build', 'Building project for verification');

    log('SUCCESS', 'Development setup completed successfully', {
      nextSteps: [
        'Run "npm run dev" to start development server',
        'Open http://localhost:3000 in your browser',
        'Check console for Observable Implementation logs'
      ]
    });

    // Observable Implementation: Performance metrics
    log('INFO', 'Setup performance summary', {
      duration: process.uptime() * 1000 + 'ms',
      memoryUsage: process.memoryUsage(),
    });

  } catch (error) {
    log('ERROR', 'Setup failed', { 
      error: error.message,
      stack: error.stack 
    });
    process.exit(1);
  }
};

// Graceful error handling
process.on('uncaughtException', (error) => {
  log('ERROR', 'Uncaught exception during setup', {
    error: error.message,
    stack: error.stack
  });
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  log('ERROR', 'Unhandled promise rejection during setup', {
    reason: reason?.toString(),
    promise: promise?.toString()
  });
  process.exit(1);
});

// Run setup
main(); 